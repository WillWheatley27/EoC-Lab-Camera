#include "oled_ssd1306.h"

#include <string.h>

#include "driver/gpio.h"
#include "driver/i2c.h"
#include "esp_log.h"
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "i2c_bus.h"

#define OLED_I2C_ADDR 0x3C
#define OLED_SDA_GPIO 41
#define OLED_SCL_GPIO 42
#define OLED_I2C_FREQ_HZ 100000

#define OLED_WIDTH 128
#define OLED_HEIGHT 32
#define OLED_PAGES (OLED_HEIGHT / 8)

static const char *TAG = "oled";

static const uint8_t s_font5x7[] = {
    0x00,0x00,0x00,0x00,0x00, // 0x20 ' '
    0x00,0x00,0x5f,0x00,0x00, // 0x21 '!'
    0x00,0x07,0x00,0x07,0x00, // 0x22 '"'
    0x14,0x7f,0x14,0x7f,0x14, // 0x23 '#'
    0x24,0x2a,0x7f,0x2a,0x12, // 0x24 '$'
    0x23,0x13,0x08,0x64,0x62, // 0x25 '%'
    0x36,0x49,0x55,0x22,0x50, // 0x26 '&'
    0x00,0x05,0x03,0x00,0x00, // 0x27 '''
    0x00,0x1c,0x22,0x41,0x00, // 0x28 '('
    0x00,0x41,0x22,0x1c,0x00, // 0x29 ')'
    0x14,0x08,0x3e,0x08,0x14, // 0x2a '*'
    0x08,0x08,0x3e,0x08,0x08, // 0x2b '+'
    0x00,0x50,0x30,0x00,0x00, // 0x2c ','
    0x08,0x08,0x08,0x08,0x08, // 0x2d '-'
    0x00,0x60,0x60,0x00,0x00, // 0x2e '.'
    0x20,0x10,0x08,0x04,0x02, // 0x2f '/'
    0x3e,0x51,0x49,0x45,0x3e, // 0x30 '0'
    0x00,0x42,0x7f,0x40,0x00, // 0x31 '1'
    0x42,0x61,0x51,0x49,0x46, // 0x32 '2'
    0x21,0x41,0x45,0x4b,0x31, // 0x33 '3'
    0x18,0x14,0x12,0x7f,0x10, // 0x34 '4'
    0x27,0x45,0x45,0x45,0x39, // 0x35 '5'
    0x3c,0x4a,0x49,0x49,0x30, // 0x36 '6'
    0x01,0x71,0x09,0x05,0x03, // 0x37 '7'
    0x36,0x49,0x49,0x49,0x36, // 0x38 '8'
    0x06,0x49,0x49,0x29,0x1e, // 0x39 '9'
    0x00,0x36,0x36,0x00,0x00, // 0x3a ':'
    0x00,0x56,0x36,0x00,0x00, // 0x3b ';'
    0x08,0x14,0x22,0x41,0x00, // 0x3c '<'
    0x14,0x14,0x14,0x14,0x14, // 0x3d '='
    0x00,0x41,0x22,0x14,0x08, // 0x3e '>'
    0x02,0x01,0x51,0x09,0x06, // 0x3f '?'
    0x32,0x49,0x79,0x41,0x3e, // 0x40 '@'
    0x7e,0x11,0x11,0x11,0x7e, // 0x41 'A'
    0x7f,0x49,0x49,0x49,0x36, // 0x42 'B'
    0x3e,0x41,0x41,0x41,0x22, // 0x43 'C'
    0x7f,0x41,0x41,0x22,0x1c, // 0x44 'D'
    0x7f,0x49,0x49,0x49,0x41, // 0x45 'E'
    0x7f,0x09,0x09,0x09,0x01, // 0x46 'F'
    0x3e,0x41,0x49,0x49,0x7a, // 0x47 'G'
    0x7f,0x08,0x08,0x08,0x7f, // 0x48 'H'
    0x00,0x41,0x7f,0x41,0x00, // 0x49 'I'
    0x20,0x40,0x41,0x3f,0x01, // 0x4a 'J'
    0x7f,0x08,0x14,0x22,0x41, // 0x4b 'K'
    0x7f,0x40,0x40,0x40,0x40, // 0x4c 'L'
    0x7f,0x02,0x0c,0x02,0x7f, // 0x4d 'M'
    0x7f,0x04,0x08,0x10,0x7f, // 0x4e 'N'
    0x3e,0x41,0x41,0x41,0x3e, // 0x4f 'O'
    0x7f,0x09,0x09,0x09,0x06, // 0x50 'P'
    0x3e,0x41,0x51,0x21,0x5e, // 0x51 'Q'
    0x7f,0x09,0x19,0x29,0x46, // 0x52 'R'
    0x46,0x49,0x49,0x49,0x31, // 0x53 'S'
    0x01,0x01,0x7f,0x01,0x01, // 0x54 'T'
    0x3f,0x40,0x40,0x40,0x3f, // 0x55 'U'
    0x1f,0x20,0x40,0x20,0x1f, // 0x56 'V'
    0x3f,0x40,0x38,0x40,0x3f, // 0x57 'W'
    0x63,0x14,0x08,0x14,0x63, // 0x58 'X'
    0x07,0x08,0x70,0x08,0x07, // 0x59 'Y'
    0x61,0x51,0x49,0x45,0x43, // 0x5a 'Z'
    0x00,0x7f,0x41,0x41,0x00, // 0x5b '['
    0x02,0x04,0x08,0x10,0x20, // 0x5c '\\'
    0x00,0x41,0x41,0x7f,0x00, // 0x5d ']'
    0x04,0x02,0x01,0x02,0x04, // 0x5e '^'
    0x40,0x40,0x40,0x40,0x40, // 0x5f '_'
    0x00,0x01,0x02,0x04,0x00, // 0x60 '`'
    0x20,0x54,0x54,0x54,0x78, // 0x61 'a'
    0x7f,0x48,0x44,0x44,0x38, // 0x62 'b'
    0x38,0x44,0x44,0x44,0x20, // 0x63 'c'
    0x38,0x44,0x44,0x48,0x7f, // 0x64 'd'
    0x38,0x54,0x54,0x54,0x18, // 0x65 'e'
    0x08,0x7e,0x09,0x01,0x02, // 0x66 'f'
    0x0c,0x52,0x52,0x52,0x3e, // 0x67 'g'
    0x7f,0x08,0x04,0x04,0x78, // 0x68 'h'
    0x00,0x44,0x7d,0x40,0x00, // 0x69 'i'
    0x20,0x40,0x44,0x3d,0x00, // 0x6a 'j'
    0x7f,0x10,0x28,0x44,0x00, // 0x6b 'k'
    0x00,0x41,0x7f,0x40,0x00, // 0x6c 'l'
    0x7c,0x04,0x18,0x04,0x78, // 0x6d 'm'
    0x7c,0x08,0x04,0x04,0x78, // 0x6e 'n'
    0x38,0x44,0x44,0x44,0x38, // 0x6f 'o'
    0x7c,0x14,0x14,0x14,0x08, // 0x70 'p'
    0x08,0x14,0x14,0x18,0x7c, // 0x71 'q'
    0x7c,0x08,0x04,0x04,0x08, // 0x72 'r'
    0x48,0x54,0x54,0x54,0x20, // 0x73 's'
    0x04,0x3f,0x44,0x40,0x20, // 0x74 't'
    0x3c,0x40,0x40,0x20,0x7c, // 0x75 'u'
    0x1c,0x20,0x40,0x20,0x1c, // 0x76 'v'
    0x3c,0x40,0x30,0x40,0x3c, // 0x77 'w'
    0x44,0x28,0x10,0x28,0x44, // 0x78 'x'
    0x0c,0x50,0x50,0x50,0x3c, // 0x79 'y'
    0x44,0x64,0x54,0x4c,0x44, // 0x7a 'z'
    0x00,0x08,0x36,0x41,0x00, // 0x7b '{'
    0x00,0x00,0x7f,0x00,0x00, // 0x7c '|'
    0x00,0x41,0x36,0x08,0x00, // 0x7d '}'
    0x10,0x08,0x08,0x10,0x08, // 0x7e '~'
    0x00,0x06,0x09,0x09,0x06  // 0x7f DEL
};

static esp_err_t s_i2c_write(uint8_t control, const uint8_t *data, size_t len)
{
    uint8_t buffer[1 + OLED_WIDTH];
    buffer[0] = control;
    if (len > 0) {
        memcpy(&buffer[1], data, len);
    }

    return i2c_master_write_to_device(i2c_bus_get_port(), OLED_I2C_ADDR, buffer, 1 + len, pdMS_TO_TICKS(200));
}

static esp_err_t s_write_cmd(uint8_t cmd)
{
    return s_i2c_write(0x00, &cmd, 1);
}

static esp_err_t s_write_data(const uint8_t *data, size_t len)
{
    return s_i2c_write(0x40, data, len);
}

static esp_err_t ssd1306_clear(void)
{
    uint8_t clear[OLED_WIDTH];
    memset(clear, 0x00, sizeof(clear));
    for (int page = 0; page < OLED_PAGES; page++) {
        esp_err_t ret = s_write_cmd(0xB0 | page);
        if (ret != ESP_OK) {
            return ret;
        }
        ret = s_write_cmd(0x00);
        if (ret != ESP_OK) {
            return ret;
        }
        ret = s_write_cmd(0x10);
        if (ret != ESP_OK) {
            return ret;
        }
        ret = s_write_data(clear, sizeof(clear));
        if (ret != ESP_OK) {
            return ret;
        }
    }
    return ESP_OK;
}

esp_err_t oled_ssd1306_init(void)
{
    ESP_LOGI(TAG, "OLED I2C pins: SDA=%d SCL=%d addr=0x%02X", OLED_SDA_GPIO, OLED_SCL_GPIO, OLED_I2C_ADDR);
    if (!i2c_bus_is_init()) {
        ESP_LOGE(TAG, "I2C bus not initialized");
        return ESP_ERR_INVALID_STATE;
    }

    esp_err_t ret = s_write_cmd(0xAE); // display off
    if (ret == ESP_OK) ret = s_write_cmd(0xD5); // set display clock
    if (ret == ESP_OK) ret = s_write_cmd(0x80);
    if (ret == ESP_OK) ret = s_write_cmd(0xA8); // multiplex
    if (ret == ESP_OK) ret = s_write_cmd(0x1F); // 0x1F for 32 rows
    if (ret == ESP_OK) ret = s_write_cmd(0xD3); // display offset
    if (ret == ESP_OK) ret = s_write_cmd(0x00);
    if (ret == ESP_OK) ret = s_write_cmd(0x40); // start line
    if (ret == ESP_OK) ret = s_write_cmd(0x8D); // charge pump
    if (ret == ESP_OK) ret = s_write_cmd(0x14);
    if (ret == ESP_OK) ret = s_write_cmd(0x20); // memory mode
    if (ret == ESP_OK) ret = s_write_cmd(0x00); // horizontal addressing
    if (ret == ESP_OK) ret = s_write_cmd(0xA1); // segment remap
    if (ret == ESP_OK) ret = s_write_cmd(0xC8); // COM scan dec
    if (ret == ESP_OK) ret = s_write_cmd(0xDA); // COM pins
    if (ret == ESP_OK) ret = s_write_cmd(0x02);
    if (ret == ESP_OK) ret = s_write_cmd(0x81); // contrast
    if (ret == ESP_OK) ret = s_write_cmd(0x8F);
    if (ret == ESP_OK) ret = s_write_cmd(0xA4); // display follow RAM
    if (ret == ESP_OK) ret = s_write_cmd(0xA6); // normal display
    if (ret == ESP_OK) ret = s_write_cmd(0xAF); // display on

    ESP_LOGI(TAG, "SSD1306 initialized");
    if (ret == ESP_OK) {
        ret = ssd1306_clear();
    }
    return ret;
}

esp_err_t oled_ssd1306_display_text(const char *text)
{
    uint8_t buffer[OLED_WIDTH * OLED_PAGES];
    memset(buffer, 0x00, sizeof(buffer));

    int x = 0;
    int page = 0;
    for (const char *p = text; *p != '\0' && page < OLED_PAGES; p++) {
        char c = *p;
        if (c == '\n') {
            x = 0;
            page++;
            continue;
        }
        if (c < 0x20 || c > 0x7f) {
            c = '?';
        }
        if (x + 6 > OLED_WIDTH) {
            x = 0;
            page++;
            if (page >= OLED_PAGES) {
                break;
            }
        }
        int index = (c - 0x20) * 5;
        int base = page * OLED_WIDTH + x;
        for (int col = 0; col < 5; col++) {
            buffer[base + col] = s_font5x7[index + col];
        }
        x += 6;
    }

    esp_err_t ret = ESP_OK;
    for (int p = 0; p < OLED_PAGES; p++) {
        ret = s_write_cmd(0xB0 | p);
        if (ret != ESP_OK) {
            break;
        }
        ret = s_write_cmd(0x00);
        if (ret != ESP_OK) {
            break;
        }
        ret = s_write_cmd(0x10);
        if (ret != ESP_OK) {
            break;
        }
        ret = s_write_data(&buffer[p * OLED_WIDTH], OLED_WIDTH);
        if (ret != ESP_OK) {
            break;
        }
    }
    return ret;
}
